# Линии

## Пошаговый алгоритм разложения отрезка в растр.
```c
int step // шаг
int point = start // текущая точка
int end // конечная точка
Блок выборки:
    if (end - point < EPS)
        return
    else if (end - point < 0)
        point -= step
    else if (end - point > 0)
        point += step
```

## ЦДА
```c
Проверить на вырожденность
if (abs(x2 - x1) > abs(y2 - y1))
    L = abs(x2 - x1)
else
    L = abs(y2 - y1)

dx = (x2 - x1) / L
dy = (y2 - y1) / L

x = x1
y = y1
for (int i = 1; i <= L; i++)
{
    Point(E(x), E(y))
    x += dx
    y += dy
}
```

Алгоритмы Брезенхема
```c
dx = (x2 - x1)
dy = (y2 - y1)

x = x1
y = x2

m = dx / dy

e = m - 0.5
while (x < x2)
{
    Plot(x, y)
    if (e >= 0)
    {
        e -= 1;
        y++;
    }
    x++;
    e += m;  
}
```

Общий Целочисленный алгоритм Брезенхема
```c
dx = (x2 - x1)
dy = (y2 - y1)

sx = sign(dx)
sy = sign(dy)

if (dy > dx)
    flag = 1
    swap(dy, dx)
else
    flag = 0

m = dx / dy

e = 2 * dx - dx

x = x1
y = x2

for (int i = 1; i <= dx; i++)
{
    if (e > 0)
    {
        if (!flag)
            y += sy; 
        else
            x += sx;
        e -= 2 * dx
    }
    if (!flag)
        x += sx;
    else
        y += sy; 
    e += 2 * dy
}
```

##  Алгоритм Брезенхема с устранением ступенчатости.
```c
I // интенсивность
dx = (x2 - x1)
dy = (y2 - y1)

m = I * (dy / dx)

w = I - m;

e = I / 2;

x = x1
y = x2

while (x < x2)
{
    x++
    if (e < w)
    {
        e += m;
    }
    else
    {
        y++;
        e -= w;
    }
    Plot (x, y, e);
}
```

## Алгоритм Ву
```c
y = y + 0.5

dx = (x2 - x1)
dy = (y2 - y1)

m = dx / dy
for (int x = x1; x < x2; x++)
{
    d1 = y - floor(y)
    d2 = 1 - d1

    Plot(x, floor(y) + 1, d1)
    Plot(x, floor(y), d2)

    y += m;
}
```

# Окружности

## Алгоритм построения по методу средней точки
```c
x = 0; y = b;
f =  b^2 - a^2 * b + 0.25 * a^2; // точка в (1, b - 0,5); f(1, b - 0,5) = b^2 * 1^2 + a^2 * (b - 0.5)^2 - a^2 * b^2

while (b^2 * x < a^2 * y)
{
    x++;
    if (f > 0) // точка вне фигуры идём вниз
    {
        y--;
        f += 2*b^2 * x + b^2 - 2*a^2 * y // точка в (x + 1, y - 1); f(x + 1, y - 1) - f(x, y) = b^2 * ((x+1)^2 − x^2)+ a^2 * ((y−1)^2 − y^2)
    }
    else
    {
        f = f + 2*b^2 * x + b^2 // точка в (x + 1, y); f(x + 1, y) - f(x, y) = b^2 * ((x + 1)^2 - x^2)
    }
}
```
## алгоритм Брезенхема для генерации окружности
```c
x = 0;
y = R;
delta = 2(1 - R)

predel = 0;

while (y > predel)
{
    Plot(x, y)
    if (delta < 0) // внутри окружности идём на право или по диагонали
    {
        delta1 = 2(delta + y) - 1 // δ=|(xi + 1)^2 + (yi)^2 – R^2|−|(xi + 1)^2 + (yi − 1)^2 – R^2| 
        if (delta1 <= 0)
        {
            x++;
            delta += 2 * x + 1
        }
        else
        {
            x++;
            y--;
            delta += 2 * x - 2 * y + 2
        }
    }
    else if (delta > 0) // вне окружности вниз или по диагонали 
    {
        delta2 = 2(delta + y) - 1 // δ=|(xi+1)^2+(yi−1)^2−R^2| − |(xi)^2+(yi−1)^2−R^2|
        if !(delta2 <= 0)
        {
            x++;
            delta += 2 * x + 1
        }
        else
        {
            x++;
            y--;
            delta += 2 * x - 2 * y + 2
        }
    }
    else
    {
        x++;
        y--;
        delta += 2 * x - 2 * y + 2
    }
}
```

# Проходка по рёбрам

## Простой алгоритм с упорядоченным списком ребер 

важно что этот алгос подходит для работы только с одним многоугольником
```c
edges[]
for (для каждого ребра)
    edges.add(все точки пересечения с y этой ребра)

sort(edges) // с начала по y потом по x

for (int y = edges.min_y; y < edges.max_y; y++)
{
    edges_y = получаем_все_точки_с_y(edges, y); 
    // вообще конечно это говно по сути просто можно идти по точкам пока y не измениться
    // но в качестве лучшего понимания агоса пишу так

    for (edges_y)
    {
        делаем пару point1 point2 из edges_y;
        закрасить_между(point1, point2);
    }
}
```
алгос можно улучшить если юзать не один массив для всех точек а делать y группы

## Алгоритм с упорядоченным списком ребер с САР

очень рекомендую нормально разобраться в этом алгоритме

```c
y_group = [[]]
for (для каждого ребра edge)
    y_group[edge.max_y].add(x, Δx, Δy) // x - пересечение со скан строкой
                                       // Δx – шаг приращения x при переходе от одной строки на другую
                                       // Δy – число скан. строк, пересекаемый ребром и указатель на след

cap = []
for (идём по скан строкам y)
{
    sort(y_group[y]) // сортируем по x
    cap.add(y_group[y])
    for (cap)
    {
        point1 = cap[i];
        point2 = cap[i + 1];
        закрасить_между(point1, point2);

        point1.x += point1.Δx
        point1.Δy--;

        if(point1.Δy <= 0)
            cap.del(point1);

        point2.x += point2.Δx
        point2.Δy--;

        if(point2.Δy <= 0)
            cap.del(point2);
    }
}
```

# Закраска

## Алгоритм заполнения по ребрам
```c
for (для каждого ребра) // порядок не важен
{
    for (для каждой точки ребра)
        точка(x, y) // из ребра
        закрасить_между((x + 1/2, y), end); // при чём закраска тут может инвертировать!!!
}
```
## Алгоритм заполнения по ребрам с перегородкой

```c
for (edge in edges)
{
    for ((x, y) in edge)
    {
        if (x < перегородка_x)
            закрасить_между((x + 1/2, y), перегородка); // при этом важно что тут (x, y) это центр пиксела
        else
            закрасить_между(перегородка, (x + 1/2, y)); 
    }
}
```

## Алгоритм со списком ребер и флагом
```c
# Обрисовка контура
Используя соглашения о середине интервала между сканирующими строками для
каждого ребра, пересекающего сканирующую строку, отметить самый левый пиксел,
центр которого лежит справа от пересечения, т.е. x + 1/2 > x_пересечения.
# Заполнение
Для каждой скан. строки, пересек. многоугл.
    Внутри = False
    for x = 0 (левая граница) to x = x_max (правая граница)
        if пиксел в точке x имеет граничной Внутри:
            Внутри = not Внутри
        if Внутри == True:
            x покрасить в цвет заливки
        else
            x покрасить в цвет фона
```

## Простой алгоритм заполнения с затравкой.

```c
Пиксель(x, y) = ЗатравПиксель(x, y)
Push(Пиксель(x, y))
while (стек не пустой)
    Pop(Пиксель(x, y))
    // новое_значение - цвет, которым мы хотим закрасить область
    if (Пиксель(x, y) != новое_значение)
        Пиксель(x, y) = новое_значение

    if (Пиксель(x + 1, y) != новое_значение && Пиксель(x + 1, y) != граничное_значение)
        Push(Пиксель(x + 1, y))
    if (Пиксель(x, y + 1) != новое_значение && Пиксель(x, y + 1) != граничное_значение)
        Push(Пиксель(x, y + 1))
    if (Пиксель(x - 1, y) != новое_значение && Пиксель(x - 1, y) != граничное_значение)
        Push(Пиксель(x - 1, y))
    if (Пиксель(x, y - 1) != новое_значение && Пиксель(x, y - 1) != граничное_значение)
        Push(Пиксель(x, y - 1))
```

## Построчный алгоритм заполнения с затравкой.
```c
push(Затравочный(x, y))
while (стек не пуст)
{
    pop(p(x, y));
    p(x, y) = цвет;

    x_start = x;
    x++;

    while(p(x, y) != граничное_значение)
    {
        p(x, y) = цвет;
        x++;
    }

    x_right = x - 1;
    x = x_start;
    x--;

    while(p(x, y) != граничное_значение)
    {
        p(x, y) = цвет;
        x--;
    }

    x_left = x + 1
    
    x = x_left
    y++;

    // ищем новый затравочный пиксел самый правый с верху и с низу
    while(x < x_right)
    {
        flag = 0;
        while (x < x_right && p(x, y) != граничное_зн && p(x, y) != новое_зн)
        {
            flag = 1;
            x++;
        }
            

        if (flag)
        {
            if (x == xr && p(x, y) != граничное_зн && p(x, y) != новое_зн)
                push(p(x, y)) // дошили до края но пиксел чистый
            else
                push(p(x - 1, y)) // пиксел грязный берём прошлый
            flag = 0;
        }

        x_enter = x
        // проход для разрыва интервала
        while (x < xr && (p(x, y) == граничное_зн || p(x, y) == новое_зн))
            x++

        if (x == x_enter)
            x++
        
    }
    // подобный цикл и для y--;
}
```

# отсечение

## Простой алгоритм отсечения отрезка.
```c
p1(x1, y1) p2(x2, y2) //параметры отрезка
x_left x_right y_up y_down // параметры окна

code1 = код_для_точки(p1)
code2 = код_для_точки(p2)

if (code1 == 0 && code2 == 0)
{
    draw_line(p1, p2);
    return
}
if (code1 & code2 == 1)
    return 

res = []

if (code1 == 0)
    res.add(p1)

if (code2 == 0)
    res.add(p2)

if (x1 == x2)
    flag = 1
else
    flag = 0

while(len(res) != 0)
{
    p(x, y) = получить_необработанную_точку()

    if (flag)
    {
        y_new;
        if (y < y_down)
            y_new = y_down;
        if (y > y_up)
            y_new = y_up;
        else
            continue
        if (min(y1, y2) < y_new < max(y1, y2))
        {
            res.add((x, y_new));
            continue
        }

        if (x < x_left)
        {
            y_new = m * (x_left - x) + y;
            if (y_down < y_new < y_up)
                res.add(p(x_left, y_new))
        }

        if (x > x_right)
        {
            y_new = m * (x_right - x) + y;
            if (y_down < y_new < y_up)
                res.add(p(x_right, y_new))
        }

        if (y > y_up)
        {
            x_new = (y_up - y) / m + x;
            if (x_left < x_new < x_right)
                res.add(p(x_new, y_up))
        }

        if (y < y_down)
        {
            x_new = (y_down - y) / m + x;
            if (x_left < x_new < x_right)
                res.add(p(x_new, y_down))
        }
    }
}
```

## Алгоритм Сазерленда-Коэна отсечения отрезка.
```c
p1(x1, y1) p2(x2, y2) //параметры отрезка
x_left x_right y_up y_down // параметры окна

flag = 0
if (x1 == x2)
    flag = -1 // верт. прямая
else
    m = (y2 - y1) / (x2 - x1)
    if m == 0:
        flag = 1 // гориз.


for (int i = 0; i < 4; i++)
{
    code1 = код_для_точки(p1)
    code2 = код_для_точки(p2)

    if (code1 == 0 && code2 == 0)
    {
        draw(p1, p2);
        return
    }

    if (code1 & code2 == 1)
        return

    if (code1 == 0) 
        swap(p1, p2)

    if (flag == -1)
        y1 = окно[i]
    else if (flag == 1)
        x1 = окно[i]
    else
    {
        if (i < 2)
        {
            y1 = m * (окно[i] - x1) + y1
            x1 = окно[i]
        }
        else
        {
            x1 = (окно[i] - y1) / m + x1
            y1 = окно[i]
        }
    }
}
```

## Алгоритм разбиения средней точкой при отсечении отрезка.
```c
p1(x1, y1) p2(x2, y2) //параметры отрезка
x_left x_right y_up y_down // параметры окна

p_start = p1
while (i <= 2)
{
    code1 = код_для_точки(p1)
    code2 = код_для_точки(p2)

    if (code1 == 0 && code2 == 0)
    {
        draw_line(p1, p2)
        return
    }

    if (code1 & code2 == 1)
        return

    if (code2 == 0)
        p1, p2, = p2, p_start
        i++;
        continue
    
    while(distance(p1, p2) > EPS)
    {
        p_mid = (p1 + p2) / 2;
        code_min;
        if (code_min & code2 == 0)
            p1 = p_min
        else
            p2 = p_min
    }
    p1, p2, = p2, p_start
    i++
}

if (code1 & code2 != 0)
    return

draw(p1, p2)
```
## Алгоритм Кируса-Бека отсечения отрезка
```c
p1, p2
k // количество граней

t_start = 0
t_end = 1

d = p2 - p1

for (int i = 0 i < k; i++)
{
    w = p1 - fi
    dn = скалярное_произведение(dn, ni)
    wn = скалярное_произведение(w, ni)

    if (dn == 0)
    {
        if (wn < 0)
            return
        else
            continue
    }

    t = -(wn/dn)

    if (dn > 0)
        t_start = max(t_start, t)
    else
        t_end = min(t_end, t);

    if (t_end < t_start)
        return
}

p1 = p1 + D * t_start
p2 = p1 + D * t_end

draw(p1, p2);
```

# Удаление невидимых отрезков в 3d

## Алгоритм плавающего горизонта
```c
первые 2 z рисуем и заполняем верхний и нижний полигон
left_point
right_point
up[]
down[]
for (идём по z)
{
    new_left_point = получаем крайне левую точку
    Line(left_point, new_left_point);
    left_point = new_left_point;
    for (int x = left_point + 1; x < new_right_point; x += dx)
    {
        new_point = (x, y) // y получаем из функции
        if (new_point.y > up[x])
        {
            up[x] = new_point.y
            if(last_point.y > up[x])
                Line(last_point, new_point);
            else
            {
                dy_horizon = up[x] - up[x + 1]
                dy_polygon = new_point.y - last_point.y
                x_new = ((new_point.y - last_point.y) * dx) / (dy_polygon - dy_horizon);
                y_new = f(x_new, z);
                Line((x_new, y_new), new_point)
            }
        }
        else if (new_point.y < down[x])
        {
            down[x] = new_point.y
            if(last_point.y < down[x])
                Line(last_point, new_point);
            else
            {
                dy_horizon = down[x] - down[x + 1]
                dy_polygon = new_point.y - last_point.y
                x_new = ((new_point.y - last_point.y) * dx) / (dy_polygon - dy_horizon);
                y_new = f(x_new, z);
                Line((x_new, y_new), new_point)
            }
        }
        else if (прошлая точка была видна)
        {
            dy_horizon = up[x] - up[x + 1]
            dy_polygon = new_point.y - last_point.y
            x_new = ((new_point.y - last_point.y) * dx) / (dy_polygon - dy_horizon);
            y_new = f(x_new, z);
            Line((x_new, y_new), last_point)
        }
    }
    last_point = new_point

    new_right_point = получаем крайне правую точку
    Line(right_point, new_right_point);
    right_point = new_right_point;

}
```

## Алгоритм Робертса
### Подготовка исходных данных

я предлагаю алгос для нахождение через 3 точки
```c
V = []
for (для каждой плоскости plane)
{
    p1 = получить_точку_на_плоскости(plane);
    p2 = получить_точку_на_плоскости(plane);
    p3 = получить_точку_на_плоскости(plane);

    v1 = p3 - p1
    v2 = p2 - p1
    
    a = v1.y * v2.z - v2.y * v1.z
    b = v1.z * v2.x - v2.z * v1.x
    c = v1.x * v2.y - v2.x * v1.y

    d = -(a * p1.x + b * p1.y + c * p1.z)

    p_internal = вычислить_внутреннюю_точку(тело)  # например, среднее всех вершин

    value = a * p_internal.x + b * p_internal.y + c * p_internal.z + d

    if (value < 0)
    {
        a = -a
        b = -b
        c = -c
        d = -d
    }

    v.add([a, b, c, d]);
}
```

### Удаление ребер, экранируемых самим телом
```c
// вектор наблюдателя может быть другого значения но это самое простое 
// наблюдатель находиться в +бесконечности по Z смотрит на начало координат
E = (0, 0, -1, 0)
for ([a, b, c, d] in V)
{
    if ([a, b, c, d] * E < 0)
        грань[i] = невидима
    else if ([a, b, c, d] * E == 0)
        грань[i] = для нас как отрезок
    else
        грань[i] = видна
}
// этот цикл только если в друг у нас один объект в ином случае идём по алгосу дальше
for (ребро in фигура)
{
    if (!(ребро.грань1 == невидима &&  ребро.грань2 == невидима))
    {
        рисуем это ребро
    }
}
```

### Удаление отрезков, экранируемых другими телами
```c
// этот цикл для всех объектов на сцене по хорошему эти объекты сортировать по z
for (для каждого ребра edge)
{
    s = edge.p1;
    d = edge.p2 - edge.p1;
    g = вектор_наблюдения
    res_t = []
    for (для каждой фигуры figure)
    {
        // умножаем на матрицу тела получим столбчатую матрицу размером n где n количество наших граней
        p = s * V 
        q = d * V
        w = g * V
        
        res_alfa = []
        for (int i = 0; i < n; i++)
        {
            if (pi < 0 && qi == 0 && wi == 0)
            {
                //отрезок полностью видим тикаем от сюда
                выход из цикла переход к следующей фигуре
            }
            if (qi != 0 && wi != 0)
            {
                // в этом случае мы ищем точки протыкания подтавляем как альфа как 0 и ищем t
                t = -p[i] / q[i];
                if (t >= 0 && t <= 1)
                    res_t.add(t);
            }
            if (qi != 0)
            {
                // из уравнения вида p + qt = 0 находим t
                t = -p[i] / q[i];
                if (t >= 0 && t <= 1)
                    res_t.add(t);
            }
            if (wi)
            {
                // вычисляем alfa зачем я хз
                // или не вычисляем)))
            }
        }
        if (len(res_t) == 1)
            выбираем_вторую_видимую_t либо 1 либо 0
    }
    // тут у нас будет массив t как то с их способом мы найдём где будут точки))) 
    // по сути если вы это на одном примере покажите я думаю вы будет уже достойны зачёта ну я надеюсь
}
```


## Варнок
```c
polygon[n] // массив многоугольников на нашей сцене
push (0, 0, Wmax) // заносим всё окно при старте
while (стек не пуст)
{
    pop (Окно (X Y W))
    for (int i = 0; i < n; i++)
    {
        if (polygon[i] внешний)
            continue
        
        if (W > 1)
        {
            W /= 2
            push(X + W, Y + W, W)
            push(X, Y + W, W)
            push(X + W, Y, W)
            push(X, Y, W)
        }
        else
        {
            if (окно пусто)
                изображаем цветом фона
            else
            {
                ищем многоугольник с максимальным Z в этом пикселе 
                и отображаем его цвет
            }
        }
    }
}
```

## Алгоритм Вейлера Азертона
```c
// сортируем по zmax (чтобы первый был ближний)
sort(polygon, z_max)

for (int i = 0; i < polygon.size(); i++) 
{
    clipper = polygon[i]   // текущий отсекатель

    // новый список для результата после обработки всех остальных
    new_polygons = []

    for (int j = i + 1; j < polygon.size(); j++) 
    {
        // делим polygon[j] на две части
        inside_list, outside_list = отсечение(clipper, polygon[j])

        // обрабатываем куски, которые попали внутрь clipper
        for (int k = 0; k < inside_list.size(); k++) 
        {
            if (inside_list[k].zmax < clipper.zmin) 
            {
                // полностью скрыт → выкидываем
                continue
            } 
            else 
            {
                // частично скрыт → рекурсивно режем
                рекурсивное_отсечение(inside_list[k], clipper)
                new_polygons.add(inside_list[k])
            }
        }

        // снаружи всегда сохраняем
        for (int k = 0; k < outside_list.size(); k++) 
        {
            new_polygons.add(outside_list[k])
        }
    }

    // заменяем список многоугольников на новый
    polygon = new_polygons
}
```

## Алгоритм, использующий список приоритетов.
```c
sort(polygon, z_min);  // сортируем полигоны по глубине (дальше -> ближе)
frame_buffer;          // буфер кадра (список нарисованных полигонов)

for (int i = 0; i < len(polygon); i++)
{
    p = polygon[i];
    q = polygon[i + 1];  // ближайший следующий многоугольник в списке
    
    if (p.z_max <= q.z_min)
    {
        // 2.1. P полностью за Q -> он не может экранировать
        frame_buffer.add(p);
    }
    else
    {
        // 2.2. P потенциально экранирует Q или других
        q_set = сформировать_список_подобных_q(p.z_max, q.z_min);

        // теперь прогоняем серию тестов
        for (each q in q_set)
        {
            bool pass = false;

            // 2.2.1 bounding box по X
            if (!пересекаются_по_X(p, q)) { pass = true; }
            // 2.2.2 bounding box по Y
            else if (!пересекаются_по_Y(p, q)) { pass = true; }
            // 2.2.3 P целиком за плоскостью Q
            else if (лежит_по_ту_сторону(p, q.плоскость)) { pass = true; }
            // 2.2.4 Q целиком за плоскостью P
            else if (лежит_по_ту_сторону(q, p.плоскость)) { pass = true; }
            // 2.2.5 проекции не перекрываются
            else if (!проекции_пересекаются(p, q)) { pass = true; }

            if (pass)
            {
                // нашёлся тест, который говорит "P не экранирует Q"
                frame_buffer.add(p);
            }
        }

        // если не найдено ни одного подтверждения, что P не экранирует
        // => P действительно может закрывать Q
        if (!frame_buffer.contains(p))
        {
            // 3. пробуем переставить P и Q местами
            if (q.помечен_как_уже_переставленный)
            {
                // зацикливание -> режем P плоскостью Q
                new_polygons = отсечь(P, Q.плоскость);
                удалить polygon[i];
                вставить new_polygons в polygon;
                i--; // пересканировать с тем же индексом, это типо для повторения
            }
            else
            {
                // переставляем P и Q
                swap(p, q);
                q.помечен_как_уже_переставленный = true;
                i--; // снова проверим пару
            }
        }
    }
}
```

## Алгоритм построчного сканирования, использующий Z-буфер.
```c
Подготовка информации:

    1.1 Для каждого многоугольника определить самую верхнюю сканирующую строку,
    которую он пересекает.

    1.2 Занести многоугольник в группу y, соответствующую этой сканирующей строке

    1.3 Запомнить для каждого многоугольника: Δy – число строк, пересекающих этот
    многоугольник, список рёбер многоугольника, коэффициенты A, B, C, D уравнения
    плоскости многоугольника, визуальные атрибуты многоугольника

// z константная буду означать y просто как индекс например для буфера кадра опр скан строки
for (идём по сканирующим строкам y_scan) 
{
    frame_buffer[y_scan] = фоновое значение
    z_buffer = z_min

    for (edge in cap)
    {
        if (edge.ΔY < 0)
            del(edge)   // так как мы работаем с парами мы будем удалять инфу из пары только об одном ребре.      
    }
    for (polygon in cam)
    {
        if (polygon.ΔY < 0)
            del(polygon)
        else
    }

    if (y_group[y_scan] != NULL)
        cam.add(y_group[y])
        for (polygon in cam)
            cap.add(polygon.добавляем_ПАРУ) 
            // по идеи тут нужно предусмотреть вариант
            // когда из какой то пары мы удалили только одно ребро и тут надо добавить новое к старому ребру
            // 
            // так же при этом добавлении мы вычисляем такие параметры для пары как
            // 1) Xл – пересечение левого ребра с текущей сканирующей строкой
            // 2) ΔXл – приращение Xл в интервале между соседними сканирующими строками
            // 3) ΔYл – число сканирующих строк, пересекаемых левым ребром
            // 4) Xп, ΔXп, ΔYп
            // 5) ΔZх=-A/C для C≠0 (иначе ΔZх=0) – приращение по Z вдоль сканирующей строке
            // 6) ΔZy=-B/C для C≠0 (иначе ΔZy=0) – приращение по Z в интервале между соседними сканирующими строками
            // как это вычислять я хз

    for (pair in cap)
    {
        z = pair.z_left
        for (int x = pair.x_left; x + 1/2 <= pair.x_right; x++)
        {
            if (z_buffer[x] < z)
            {
                z_buffer[x] = z;
                frame_buffer[y_scan][x] = I // присваиваем интенсивность (цвет)
            }
            z -= pair.Δz // почему минус я хз
        }
        pair.ΔY_left--;
        pair.ΔY_right--;
        pair.x_left += pair.Δx_left
        pair.x_right += pair.Δx_right
    }

}

```

## Гуро
```c
нормаль_вершины(точка)
{
    double sum_n = 0;
    int k = 0;
    for(для всех полигонов)
    {
        точки на полигоне A B C
        u = B - A // это вектор
        v = C - A // это вектор
        n = векторное произведение(u, v)
        n /= abs(n) // нормализуем и возможно это тут не нужно)
        sum += n;
        k++;
    }
    n_res = normalize(sum)
    return n_res
}

вычисление_интенсивности(N)
{
    return Ip * Kp * скалярное_произведение(N, L)
}

//  в нашем случае мы будем закрашивать только один полигон с n рёбрами 
for (идём сканирующей строкой как по списку рёбер получаем каждый раз 2 отрезка AB CD и const_y)
{
    Na = нормаль_вершины(a);
    Nb = нормаль_вершины(b);
    Nc = нормаль_вершины(c);
    Nd = нормаль_вершины(d);
    

    Ia = вычисление_интенсивности(Na)
    Ib = вычисление_интенсивности(Nb)
    Ic = вычисление_интенсивности(Nc)
    Id = вычисление_интенсивности(Nd)

    // получаем некую точку Q на отрезке AB и R на CD
    // Их координаты можно получить за счёт движения по списку рёбер
    // это тупо наше const_y и x_left x_right
    
    u = AQ / AB
    w = CR / CD

    Iq = u * Ia + (1 - u) * Ib;
    Ir = u * Ic + (1 - u) * Id;

    t1 = (Q, (const_y, x_left + 1)) / QR;
    t2 = (Q, (const_y, x_left + 2)) / QR;

    Ip = t1 * Iq + (1 - t1) * Ir;
    ΔI = (Iq - Ir)
    Δt = (t2 - t1)

    for (int x = x_left; x + 1/2 <= x_right; x++)
    {
        рисуем(Ip);
        Ip += ΔI * Δt;
    }
}
```

## фонг
```c
нормаль_вершины(точка)
{
    vec3 sum_n = 0;
    int k = 0;
    for (все полигоны вокруг вершины)
    {
        vec3 u = B - A;
        vec3 v = C - A;
        vec3 n = cross(u, v);
        sum_n += normalize(n);  // нормализуем
        k++;
    }
    return normalize(sum_n / k);
}

// вычисление интенсивности пикселя по нормали (Фонг)
вычисление_интенсивности(N)
{
    return Ip * Kp * max(0.0, dot(N, L)); // скалярное произведение
}

// главный цикл закраски
for (идём сканирующей строкой по двум рёбрам: AB и CD)
{
    // нормали к вершинам
    Na = нормаль_вершины(a);
    Nb = нормаль_вершины(b);
    Nc = нормаль_вершины(c);
    Nd = нормаль_вершины(d);

    u = AQ / AB
    w = CQ / CD

    // дельты нормалей вдоль рёбер
    ΔN_AB = (Nb - Na) / (B.y - A.y);
    ΔN_CD = (Nd - Nc) / (D.y - C.y);

    // нормали на текущей строке
    Nq = u * Na + (1 - u) * Nb;
    Nr = w * Nc + (1 - w) * Nd;
    
    t1 = (Q, (const_y, x_left + 1)) / QR;
    t2 = (Q, (const_y, x_left + 2)) / QR;

    Np = t1 * Nq + (1 - t1) * Nr;

    ΔN = (Nq - Nr)
    Δt = (t2 - t1)

    N = Nq; // стартовая нормаль на x_left
    for (int x = x_left; x <= x_right; x++)
    {
        Np = normalize(Np);               // нормализуем перед освещением
        Ip_pixel = вычисление_интенсивности(N); // Фонг: пиксельная интенсивность
        рисуем(Ip_pixel);

        Np += ΔN * Δt; // идём по строке
    }
}
```






